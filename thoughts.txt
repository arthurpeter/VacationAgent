The search will be don e by specifying a city and country code so the exploration api will only be used
for dates and the regular search will try all airports from a city. After making the explore endpoint i will 
change the frontend so you can call them from there, then make the accomodation part and integrate it and only after that
I make the database integration for the session.

Decision: keep the explore service as a tool for the agent to make better recommendations to simplify the user
experience for the search and make better asessments fr the recommended period.

Remember the currency used in the database either session wide or user wide

new flow for better accomodations experience:
Search & Listing (The Teaser - Cost $0)

The user searches for a destination.

We display a list of "Mini Cards" using only the initial data (Bulk Search).

What the user sees: Hotel Name, Price, Small Photo (thumbnail), Rating, and a short description (extracted from accessibilityLabel).

Goal: To spark interest without consuming additional resources.

View Details (The Closer - Cost ~$1/click)

The user clicks on a hotel ("View Details").

A Modal (overlay window) opens instantly.

Initial State: Displays the data from the "Teaser" + Skeleton Loaders (loading bars) for missing content.

Background Action: The getHotelDetails API call is triggered (only for this specific hotel).

Loading & Caching (Optimization)

Once the data arrives (1-2 sec), the Modal updates with: HD Photo Gallery, Full Description, Structured Facilities, and Interactive Map.

Cache: Data is saved in the app's memory. If the user re-opens this hotel, the information appears instantly, with no extra API cost.

Booking

The final "Select & Book" button is located inside this detailed Modal, ensuring the user knows exactly what they are purchasing.

I will build a docker compose to spin up the whole project including normal database and cache

Phase 1: The Foundation (Local Setup)
    Goal: Prepare your code for the "New World" of external services.

    Move the .env file: Drag it from /backend to the project root. This makes it easier for Docker Compose to find it tomorrow.

    Update Database Logic: In backend/app/core/database.py, update the engine creation. Use os.getenv("DATABASE_URL") so it looks for Postgres, but keep the SQLite path as a fallback for safety.

    Update Cache Logic: In backend/app/core/cache.py, update the Redis connection to use os.getenv("REDIS_HOST", "localhost"). Since your backend is local, it will use localhost.

    Install Drivers: Run the following in your terminal to allow your local Python to speak to the new services:

    pip install psycopg2-binary redis

Phase 2: Orchestration (The Infrastructure)
    Goal: Launch the "Always-On" services with a single command.

    Create docker-compose.yml: In the project root, write the recipe for your shared services:

    Service db: Use image: postgres:15-alpine. Map ports "5432:5432".

    Service redis: Use image: redis:7-alpine. Map ports "6379:6379".

    Volumes: Add a postgres_data volume so your users and sessions aren't deleted when you stop Docker.

Phase 3: The "Hybrid" Run (Testing)
    Goal: Verify the connection while keeping your fast dev workflow.

    Start Infrastructure: Run docker compose up -d. This starts the DB and Cache in the background.

    Verify Backend: Start your backend locally. It should now connect to the Postgres container. Since the DB is empty, you will need to Register a new account to test.

    Verify Cache: Perform a search. Check your terminal logs for the ✅ Cache HIT or miss Cache MISS messages we planned.

Phase 5: Production Prep (The Future)
    Goal: Containerize the apps once your logic is 100% finished.

    Backend Dockerfile: Create backend/Dockerfile. It will install Python, copy your code, and run uvicorn.

    Frontend Dockerfile: Create frontend/travel-agent-app/Dockerfile. This is a "multi-stage" build:

    Stage 1: Use Node to build your React app into a dist/ folder.

    Stage 2: Use Nginx to serve that dist/ folder.

    Nginx Config: Create frontend/travel-agent-app/nginx.conf to ensure React Router works inside the container.

Game Plan: Frontend Skeleton & Supporting Screens
    Goal: Build out the remaining static screens and UX polish (empty states, loading, layout) so the entire frontend flow is clickable and looks like a finished product. No backend or database changes yet—just React, Tailwind, and React Router.

    Phase 1: Completing the Global Layout
        Before I make the static pages, they need a place to live in the UI. The Navbar handles the top, but I need a Footer for the bottom.

        [ ] Create <Footer /> component: * Path: src/components/Footer.jsx

        Action: Build a simple footer with links to "Terms of Service", "Privacy Policy", and "Contact Support". Drop this at the bottom of VacationLayout.jsx so it appears on all protected pages.

        [ ] Create Terms & Privacy Page:

        Path: src/pages/Terms.jsx

        Action: Dump standard boilerplate legal text here. Add a <Link> on the Login.jsx and Register.jsx pages ("By continuing, you agree...").

    Phase 2: User Support & Settings (The Navbar Links)
        Now that the Navbar buttons are wired up to dummy routes, I need to replace those routes with actual UI skeletons.

        [ ] Create FAQ / Help Center:

        Path: src/pages/FAQ.jsx

        Entry point: User clicks "Help" in the Navbar.

        Action: Build a static accordion UI explaining how the AI works, why prices fluctuate, and how to use the drag-and-drop itinerary.

        [ ] Create Profile Settings Skeleton:

        Path: src/pages/Profile.jsx

        Entry point: User clicks the "ME" avatar in the Navbar.

        Action: Build a static layout with tabs or sections for:

        Account Details (Email, Password reset).

        Travel Preferences (Default home airport, preferred currency).

        Saved Travelers (A vault for passport/frequent flyer info).

        Note: I will just map out the UI and input fields for now. I'll wire them up to FastAPI/Postgres later.

    Phase 3: Dashboard UX (The "Unhappy" Paths)
        The app needs to handle states where the user has no data or is waiting for data.

        [ ] Dashboard Empty State:

        Path: src/pages/Dashboard.jsx

        Action: Add conditional logic. If the user has 0 saved trips, hide the standard table/list. Show a nice illustration (like an empty suitcase) and a prominent "Start Your First Trip" button that routes directly to the AI Discovery chat.

        [ ] Global AI Loading Experience:

        Path: src/components/TripLoader.jsx (Reusable component)

        Action: The AI and SerpAPI calls will take time. Instead of a spinner, build a full-screen loading overlay that cycles through text like "Scouting flights...", "Reviewing hotels...", "Building your itinerary...".

    Phase 4: Post-Completion (Save for last)
        I will only build this after my main AI chat -> flights -> drag-and-drop itinerary flow is 100% bug-free.

        [ ] Public / Shared View:

        Path: src/pages/SharedItinerary.jsx (e.g., route /shared/:tripId)

        Action: Duplicate the ItineraryStage.jsx UI but strip out all the interactive bits (no editing, no drag-and-drop, no API calls). It should look like a clean, read-only digital brochure for users to send to friends.